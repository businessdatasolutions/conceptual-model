<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Research Conceptual Model Builder - Ishikawa Diagram</title>
    <!-- Materialize CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css"
    />
    <!-- Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <style>
      body {
        background-color: #f5f5f5;
        font-family: "Roboto", sans-serif;
      }

      #canvas-container {
        background-color: white;
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin: 20px 0;
        overflow: hidden;
        position: relative;
        height: 70vh;
      }

      #canvas {
        width: 100%;
        height: 100%;
        position: relative;
      }

      .variable {
        padding: 10px 15px;
        border-radius: 6px;
        cursor: move;
        min-width: 120px;
        max-width: 200px;
        text-align: center;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        position: absolute;
        z-index: 1;
        user-select: none;
      }

      .variable h6 {
        margin: 0;
        word-break: break-word;
        font-weight: 500;
        color: rgba(0, 0, 0, 0.87);
      }

      .variable .badge {
        margin-top: 8px;
        display: block;
        font-size: 11px;
        padding: 3px 8px;
        border-radius: 12px;
      }

      .variable .close-btn {
        position: absolute;
        top: -10px;
        right: -10px;
        background: white;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        text-align: center;
        line-height: 24px;
        cursor: pointer;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        display: none;
        color: black; /* Ensure text is black */
        font-weight: bold;
      }

      .variable:hover .close-btn {
        display: block;
      }

      .strength-control {
        margin-top: 8px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .strength-slider {
        width: 80px;
        margin-right: 8px;
        cursor: pointer; /* Show appropriate cursor */
      }

      .strength-value {
        font-size: 12px;
        min-width: 20px;
        text-align: center;
      }

      .connector-line {
        position: absolute;
        background-color: #333;
        height: 2px;
        transform-origin: 0 0;
        z-index: 0;
        cursor: pointer;
      }

      .connector-line:hover {
        background-color: #666;
        height: 4px;
      }

      .connector-line.selected {
        background-color: #7e57c2;
        height: 4px;
      }

      .arrow-head {
        position: absolute;
        width: 0;
        height: 0;
        border-style: solid;
        z-index: 0;
      }

      .ishikawa-branch {
        position: absolute;
        background-color: #333;
        height: 2px;
        transform-origin: 0 0;
        z-index: 0;
      }

      .ishikawa-main-bone {
        position: absolute;
        background-color: #333;
        height: 3px;
        left: 0;
        right: 0;
        top: 50%;
        z-index: 0;
      }

      .color-preview {
        display: inline-block;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        margin-right: 5px;
        vertical-align: middle;
      }

      .toolbar {
        padding: 15px;
        background-color: white;
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
      }

      .connection-mode {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 100;
      }

      #trash-zone {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        height: 0;
        background: rgba(244, 67, 54, 0.1);
        text-align: center;
        overflow: hidden;
        transition: height 0.3s;
        z-index: 99;
      }

      #trash-zone.visible {
        height: 80px;
      }

      #trash-zone i {
        margin-top: 20px;
        color: #f44336;
        font-size: 32px;
      }

      .legend {
        margin-top: 15px;
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
      }

      .legend-item {
        display: flex;
        align-items: center;
        margin-right: 15px;
      }

      .zoom-controls {
        position: absolute;
        bottom: 10px;
        left: 10px;
        z-index: 10;
      }

      .minimized {
        width: 40px !important;
        height: 40px !important;
        overflow: hidden;
        border-radius: 50% !important;
        padding: 0 !important;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .minimized h6,
      .minimized .badge {
        display: none;
      }

      .tooltip {
        position: absolute;
        background: rgba(97, 97, 97, 0.9);
        color: white;
        padding: 5px 10px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        pointer-events: none;
        white-space: nowrap;
      }

      #auto-layout-btn {
        animation: pulse 2s infinite;
      }

      @keyframes pulse {
        0% {
          box-shadow: 0 0 0 0 rgba(156, 39, 176, 0.4);
        }
        70% {
          box-shadow: 0 0 0 10px rgba(156, 39, 176, 0);
        }
        100% {
          box-shadow: 0 0 0 0 rgba(156, 39, 176, 0);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="row">
        <div class="col s12 center-align">
          <h4>Research Conceptual Model Builder</h4>
          <h5 class="grey-text text-darken-2">Ishikawa Diagram Guidelines</h5>
          <p class="grey-text">
            Add a dependent variable as the main "effect", independent variables
            as main "causes", and moderators as "sub-causes"
          </p>
          <p class="grey-text">
            Then click "Apply Ishikawa Layout" to organize them in a fishbone
            structure
          </p>
        </div>
      </div>

      <!-- Toolbar Section -->
      <div class="toolbar">
        <div class="row">
          <div class="input-field col s4">
            <input id="variable-name" type="text" class="validate" />
            <label for="variable-name">Variable Name</label>
          </div>

          <div class="input-field col s3">
            <select id="variable-type">
              <option value="" disabled selected>Choose type</option>
              <option value="independent" data-color="#26a69a">
                Independent
              </option>
              <option value="dependent" data-color="#ef5350">Dependent</option>
              <option value="moderator" data-color="#7e57c2">Moderator</option>
              <option value="control" data-color="#78909c">Control</option>
              <option value="custom" data-color="#8bc34a">Custom</option>
            </select>
            <label>Variable Type</label>
          </div>

          <div class="input-field col s2">
            <input
              id="custom-color"
              type="color"
              class="validate"
              value="#8bc34a"
              disabled
            />
            <label for="custom-color" class="active">Color</label>
          </div>

          <div class="col s3">
            <button
              id="add-variable-btn"
              class="btn waves-effect waves-light"
              style="margin-top: 20px"
            >
              Add Variable
              <i class="material-icons right">add</i>
            </button>
          </div>
        </div>

        <!-- Legend -->
        <div class="row">
          <div class="legend-item">
            <span
              class="color-preview"
              style="background-color: #26a69a"
            ></span>
            <span>Independent (Main Causes)</span>
          </div>
          <div class="legend-item">
            <span
              class="color-preview"
              style="background-color: #ef5350"
            ></span>
            <span>Dependent (Effect/Outcome)</span>
          </div>
          <div class="legend-item">
            <span
              class="color-preview"
              style="background-color: #7e57c2"
            ></span>
            <span>Moderator (Strength 1-10) / Mediator (Strength 0)</span>
          </div>
          <div class="legend-item">
            <span
              class="color-preview"
              style="background-color: #78909c"
            ></span>
            <span>Control</span>
          </div>
          <div class="legend-item">
            <span
              class="color-preview"
              style="background-color: #8bc34a"
            ></span>
            <span>Custom</span>
          </div>
        </div>
      </div>

      <!-- Canvas Container -->
      <div id="canvas-container">
        <div id="canvas"></div>

        <div class="zoom-controls">
          <button
            id="zoom-in-btn"
            class="btn-floating btn-small waves-effect waves-light grey"
          >
            <i class="material-icons">add</i>
          </button>
          <button
            id="zoom-out-btn"
            class="btn-floating btn-small waves-effect waves-light grey"
          >
            <i class="material-icons">remove</i>
          </button>
          <button
            id="zoom-reset-btn"
            class="btn-floating btn-small waves-effect waves-light grey"
          >
            <i class="material-icons">aspect_ratio</i>
          </button>
        </div>
      </div>

      <!-- Connection Mode Button -->
      <div class="connection-mode">
        <button
          id="toggle-connect-mode"
          class="btn-floating btn-large waves-effect waves-light blue tooltipped"
          data-position="left"
          data-tooltip="Toggle Connection Mode"
        >
          <i class="material-icons">swap_horiz</i>
        </button>
        <!-- Added the missing moderator mode button -->
        <button
          id="toggle-moderator-mode"
          class="btn-floating btn-large waves-effect waves-light purple lighten-2 tooltipped"
          data-position="left"
          data-tooltip="Toggle Moderator Attachment Mode"
          style="margin-top: 10px"
        >
          <i class="material-icons">trending_up</i>
        </button>
      </div>

      <!-- Project Actions -->
      <div class="row">
        <div class="col s12">
          <button
            id="auto-layout-btn"
            class="btn waves-effect waves-light purple lighten-1"
          >
            Apply Ishikawa Layout
            <i class="material-icons right">auto_fix_high</i>
          </button>
          <button
            id="clear-canvas-btn"
            class="btn red lighten-2 waves-effect waves-light"
          >
            Clear Canvas
            <i class="material-icons right">delete</i>
          </button>
          <button id="save-btn" class="btn waves-effect waves-light">
            Save Model
            <i class="material-icons right">save</i>
          </button>
          <button id="load-btn" class="btn waves-effect waves-light">
            Load Model
            <i class="material-icons right">folder_open</i>
          </button>
          <button id="export-btn" class="btn waves-effect waves-light">
            Export as PNG
            <i class="material-icons right">image</i>
          </button>
        </div>
      </div>
    </div>

    <!-- Trash Zone -->
    <div id="trash-zone">
      <i class="material-icons">delete</i>
      <p>Drop here to delete</p>
    </div>

    <!-- Hidden file input for loading -->
    <input type="file" id="load-input" style="display: none" accept=".json" />

    <!-- Materialize JS and JQuery -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", function () {
        // Initialize Materialize components
        M.AutoInit();

        // Get references to elements
        const canvas = document.getElementById("canvas");
        const variableNameInput = document.getElementById("variable-name");
        const variableTypeSelect = document.getElementById("variable-type");
        const customColorInput = document.getElementById("custom-color");
        const addVariableBtn = document.getElementById("add-variable-btn");
        const toggleConnectModeBtn = document.getElementById(
          "toggle-connect-mode"
        );
        const toggleModeratorModeBtn = document.getElementById(
          "toggle-moderator-mode"
        );
        const clearCanvasBtn = document.getElementById("clear-canvas-btn");
        const saveBtn = document.getElementById("save-btn");
        const loadBtn = document.getElementById("load-btn");
        const loadInput = document.getElementById("load-input");
        const exportBtn = document.getElementById("export-btn");
        const trashZone = document.getElementById("trash-zone");
        const zoomInBtn = document.getElementById("zoom-in-btn");
        const zoomOutBtn = document.getElementById("zoom-out-btn");
        const zoomResetBtn = document.getElementById("zoom-reset-btn");
        const autoLayoutBtn = document.getElementById("auto-layout-btn");

        // State variables
        let variables = [];
        let connections = [];
        let connectionMode = false;
        let moderatorAttachMode = false; // New mode for attaching moderators to connections
        let selectedVariable = null;
        let selectedConnection = null; // Track which connection is selected for moderator attachment
        let draggingVariable = null;
        let offsetX, offsetY;
        let isDragging = false;
        let scale = 1;
        let tooltip = null;
        let mainDependentVar = null; // Store the main dependent variable for Ishikawa layout

        // Variable type colors
        const typeColors = {
          independent: "#26a69a",
          dependent: "#ef5350",
          moderator: "#7e57c2",
          control: "#78909c",
          custom: "#8bc34a",
        };

        // Apply Ishikawa (fishbone) diagram layout
        function applyIshikawaLayout() {
          console.log("Applying Ishikawa layout...");

          // First, check if we have variables
          if (variables.length === 0) {
            M.toast({ html: "Add some variables first" });
            return;
          }

          // Get dependent variables
          const dependentVars = variables.filter((v) => v.type === "dependent");
          console.log("Dependent variables:", dependentVars.length);

          if (dependentVars.length === 0) {
            M.toast({
              html: "Need at least one dependent variable for Ishikawa layout",
            });
            return;
          }

          // Use the first dependent variable if main not set
          if (!mainDependentVar) {
            mainDependentVar = dependentVars[0];
            console.log(
              "Setting main dependent variable:",
              mainDependentVar.name
            );
          }

          // Get independent variables
          const independentVars = variables.filter(
            (v) => v.type === "independent"
          );
          console.log("Independent variables:", independentVars.length);

          if (independentVars.length === 0) {
            M.toast({
              html: "Need at least one independent variable for Ishikawa layout",
            });
            return;
          }

          // Get moderator variables
          const moderatorVars = variables.filter(
            (v) => v.type === "moderator" && !v.modifies
          );

          // Get control variables
          const controlVars = variables.filter((v) => v.type === "control");

          // Get custom variables
          const customVars = variables.filter((v) => v.type === "custom");

          // Clear existing connections
          connections.forEach((conn) => {
            const lineEl = document.getElementById("line-" + conn.id);
            const arrowEl = document.getElementById("arrow-" + conn.id);
            if (lineEl) lineEl.remove();
            if (arrowEl) arrowEl.remove();
          });
          connections = [];

          // Reset modifies property for all moderators
          variables.forEach((v) => {
            if (v.type === "moderator") {
              v.modifies = null;
            }
          });

          // Draw the main bone of the fishbone diagram
          drawMainBone();

          // Position the dependent variable at the right end of the main bone
          const canvasWidth = canvas.clientWidth;
          const canvasHeight = canvas.clientHeight;
          const midY = canvasHeight / 2;

          // Position the main dependent variable
          const depVarEl = mainDependentVar.element;
          depVarEl.style.left = canvasWidth - depVarEl.offsetWidth - 50 + "px";
          depVarEl.style.top = midY - depVarEl.offsetHeight / 2 + "px";

          // Calculate number of branches on top and bottom
          const totalBranches = independentVars.length;
          const branchesPerSide = Math.ceil(totalBranches / 2);

          // Calculate spacing between branches
          const branchSpacing = (canvasWidth - 200) / (branchesPerSide + 1);

          // Position independent variables and create branches
          let topCount = 0;
          let bottomCount = 0;

          // Create connections first to get references
          const indConnections = [];

          independentVars.forEach((indVar, index) => {
            // Create connection first
            const conn = createConnection(indVar.id, mainDependentVar.id);
            indConnections.push(conn);

            const isTop = index % 2 === 0;
            const varEl = indVar.element;
            let branchX, branchY;

            if (isTop) {
              topCount++;
              branchX = branchSpacing * topCount;
              branchY = midY - 100; // Position above the main bone
              varEl.style.left = branchX - varEl.offsetWidth / 2 + "px";
              varEl.style.top = branchY - varEl.offsetHeight - 30 + "px";
            } else {
              bottomCount++;
              branchX = branchSpacing * bottomCount;
              branchY = midY + 100; // Position below the main bone
              varEl.style.left = branchX - varEl.offsetWidth / 2 + "px";
              varEl.style.top = branchY + 30 + "px";
            }

            // Draw branch
            drawBranch(branchX, branchY, midY, isTop);
          });

          // Distribute moderators among the independent variables' connections
          const modsPerConnection = Math.max(
            1,
            Math.floor(moderatorVars.length / indConnections.length)
          );

          let modIndex = 0;
          indConnections.forEach((conn) => {
            const modsForThisConnection = moderatorVars.slice(
              modIndex,
              modIndex + modsPerConnection
            );
            modsForThisConnection.forEach((mod) => {
              attachModeratorToConnection(mod, conn);
            });
            modIndex += modsPerConnection;
          });

          // Position any remaining moderators
          const remainingMods = moderatorVars.slice(modIndex);
          if (remainingMods.length > 0) {
            // Distribute remaining mods evenly
            remainingMods.forEach((mod, idx) => {
              const connIndex = idx % indConnections.length;
              attachModeratorToConnection(mod, indConnections[connIndex]);
            });
          }

          // Position control variables at the bottom
          if (controlVars.length > 0) {
            const controlSpacing =
              (canvasWidth - 200) / (controlVars.length + 1);
            controlVars.forEach((controlVar, index) => {
              const controlVarEl = controlVar.element;
              controlVarEl.style.left =
                100 +
                controlSpacing * (index + 1) -
                controlVarEl.offsetWidth / 2 +
                "px";
              controlVarEl.style.top =
                canvasHeight - 50 - controlVarEl.offsetHeight + "px";
            });
          }

          // Position custom variables at the left side
          if (customVars.length > 0) {
            const customSpacing =
              (canvasHeight - 200) / (customVars.length + 1);
            customVars.forEach((customVar, index) => {
              const customVarEl = customVar.element;
              customVarEl.style.left = "50px";
              customVarEl.style.top =
                100 +
                customSpacing * (index + 1) -
                customVarEl.offsetHeight / 2 +
                "px";
            });
          }

          // Update all connections
          updateConnections();

          M.toast({ html: "Ishikawa layout applied" });
        }

        // Draw main horizontal bone
        function drawMainBone() {
          // Remove existing main bone if any
          const existingBone = document.getElementById("ishikawa-main-bone");
          if (existingBone) existingBone.remove();

          const bone = document.createElement("div");
          bone.id = "ishikawa-main-bone";
          bone.className = "ishikawa-main-bone";
          canvas.appendChild(bone);
        }

        // Draw branch from main bone
        function drawBranch(x, y, mainBoneY, isTop) {
          const branch = document.createElement("div");
          branch.className = "ishikawa-branch";

          const height = Math.abs(y - mainBoneY);
          branch.style.height = height + "px";
          branch.style.left = x + "px";

          if (isTop) {
            branch.style.top = y + "px";
            branch.style.transform = "rotate(180deg)";
          } else {
            branch.style.top = mainBoneY + "px";
          }

          canvas.appendChild(branch);
        }

        // Enable/disable custom color input based on type selection
        variableTypeSelect.addEventListener("change", function () {
          const selectedOption = this.options[this.selectedIndex];
          if (selectedOption.value === "custom") {
            customColorInput.disabled = false;
          } else {
            customColorInput.disabled = true;
            if (selectedOption.dataset.color) {
              customColorInput.value = selectedOption.dataset.color;
            }
          }
        });

        // Add variable button click handler
        addVariableBtn.addEventListener("click", function () {
          const name = variableNameInput.value.trim();
          if (!name) {
            M.toast({ html: "Please enter a variable name" });
            return;
          }

          const type = variableTypeSelect.value;
          if (!type) {
            M.toast({ html: "Please select a variable type" });
            return;
          }

          const color =
            type === "custom" ? customColorInput.value : typeColors[type];

          // Default strength value for moderators
          const strength = type === "moderator" ? 5 : null;

          addVariable(name, type, color, null, strength);

          // Clear inputs
          variableNameInput.value = "";
          variableNameInput.focus();
        });

        // Add variable function
        function addVariable(name, type, color, position, strength = 5) {
          const id = "var-" + Date.now();
          const variableEl = document.createElement("div");
          variableEl.className = "variable";
          variableEl.id = id;
          variableEl.dataset.type = type;
          variableEl.dataset.strength = strength; // Store moderator strength
          variableEl.style.backgroundColor = color;
          variableEl.style.color = getContrastColor(color);

          // Use position if provided, otherwise random position
          if (position) {
            variableEl.style.left = position.left + "px";
            variableEl.style.top = position.top + "px";
          } else {
            variableEl.style.left =
              Math.floor(Math.random() * (canvas.clientWidth - 200) + 50) +
              "px";
            variableEl.style.top =
              Math.floor(Math.random() * (canvas.clientHeight - 200) + 50) +
              "px";
          }

          // For moderators, add strength control
          let strengthControl = "";
          if (type === "moderator") {
            strengthControl = `
            <div class="strength-control">
              <input type="range" min="0" max="10" value="${strength}" class="strength-slider" />
              <span class="strength-value">${strength}</span>
            </div>
          `;
          }

          variableEl.innerHTML = `
          <h6>${name}</h6>
          <span class="badge" style="background-color: ${adjustColor(
            color,
            -20
          )}; color: ${getContrastColor(color)};">${type}</span>
          ${strengthControl}
          <div class="close-btn" style="color: black;" data-id="${id}">Ã—</div>
        `;

          canvas.appendChild(variableEl);

          // Add to variables array
          const variable = {
            id,
            name,
            type,
            color,
            strength: strength,
            modifies: null, // For moderators, which connection they modify
            element: variableEl,
          };

          variables.push(variable);

          // If this is a dependent variable and no main dependent variable is set, make it the main one
          if (type === "dependent" && !mainDependentVar) {
            mainDependentVar = variable;
          }

          // Add event listeners for the variable element
          setupVariableEvents(variableEl);

          return variableEl;
        }

        // Setup events for variable elements
        function setupVariableEvents(variableEl) {
          variableEl.addEventListener("mousedown", handleVariableMouseDown);
          variableEl.addEventListener("touchstart", handleVariableTouchStart, {
            passive: false,
          });
          variableEl.addEventListener("dblclick", handleVariableDblClick);

          const closeBtn = variableEl.querySelector(".close-btn");
          if (closeBtn) {
            closeBtn.addEventListener("click", function (e) {
              e.stopPropagation();
              const varId = this.dataset.id;
              removeVariable(varId);
            });
          }

          // Add event listener for strength slider if it exists
          const strengthSlider = variableEl.querySelector(".strength-slider");
          if (strengthSlider) {
            // Stop propagation on all mouse events for the slider to prevent dragging
            ["mousedown", "mousemove", "mouseup", "click"].forEach(
              (eventName) => {
                strengthSlider.addEventListener(eventName, function (e) {
                  e.stopPropagation();
                });
              }
            );

            strengthSlider.addEventListener("input", function (e) {
              e.stopPropagation(); // Prevent dragging while adjusting slider

              const varId = variableEl.id;
              const variable = variables.find((v) => v.id === varId);
              if (variable) {
                const strength = parseInt(this.value);
                variable.strength = strength;

                // Update the displayed value
                const strengthValueEl =
                  variableEl.querySelector(".strength-value");
                if (strengthValueEl) {
                  strengthValueEl.textContent = strength;
                }

                // Update the appearance based on strength
                updateModeratorAppearance(variable);

                // If it's attached to a connection, refresh it
                if (variable.modifies) {
                  positionModeratorOnConnection(variable);
                }
              }
            });
          }
        }

        // Update moderator appearance based on strength
        function updateModeratorAppearance(variable) {
          if (variable.type !== "moderator") return;

          if (variable.strength === 0) {
            // Mediator appearance
            variable.element.style.backgroundColor = "#ffb74d"; // Mediator color
            const badge = variable.element.querySelector(".badge");
            if (badge) {
              badge.textContent = "mediator";
              badge.style.backgroundColor = adjustColor("#ffb74d", -20);
            }
          } else {
            // Moderator appearance
            variable.element.style.backgroundColor = typeColors.moderator;
            const badge = variable.element.querySelector(".badge");
            if (badge) {
              badge.textContent = "moderator";
              badge.style.backgroundColor = adjustColor(
                typeColors.moderator,
                -20
              );
            }
          }
        }

        // Handle mouse down on variable
        function handleVariableMouseDown(e) {
          if (connectionMode) {
            // Don't do anything on mousedown in connection mode
            // The canvas click handler will handle connections
            return;
          } else if (moderatorAttachMode) {
            // Handle moderator attachment mode
            const varElement = e.target.closest(".variable");
            const varId = varElement.id;
            const variable = variables.find((v) => v.id === varId);

            if (variable && variable.type === "moderator") {
              // A moderator was clicked in moderator attachment mode
              if (!selectedConnection) {
                M.toast({
                  html: "First select a connection to attach this moderator to",
                });
              } else {
                // Attach moderator to selected connection
                attachModeratorToConnection(variable, selectedConnection);
                // Reset selected connection
                selectedConnection.element.classList.remove("selected");
                selectedConnection = null;
                M.toast({ html: "Moderator attached to connection" });
              }
            } else {
              M.toast({
                html: "Only moderators can be attached to connections",
              });
            }
            return;
          } else {
            handleDragStart(e);
          }
        }

        // Handle touch start on variable
        function handleVariableTouchStart(e) {
          e.preventDefault();
          const touch = e.touches[0];
          if (connectionMode) {
            // Don't do anything in connection mode
            return;
          } else {
            handleDragStart({
              target: e.target,
              clientX: touch.clientX,
              clientY: touch.clientY,
            });
          }
        }

        // Handle variable double click
        function handleVariableDblClick(e) {
          const varElement = e.target.closest(".variable");
          if (!varElement) return;

          const varId = varElement.id;
          const variable = variables.find((v) => v.id === varId);

          if (variable) {
            if (variable.type === "dependent") {
              // Set as main dependent variable
              setAsMainDependent(varId);
            } else {
              // Toggle minimized state for non-dependent variables
              if (varElement.classList.contains("minimized")) {
                varElement.classList.remove("minimized");
              } else {
                varElement.classList.add("minimized");
              }

              // Redraw connections
              updateConnections();
            }
          }
        }

        // Handle drag start
        function handleDragStart(e) {
          const varElement = e.target.closest(".variable");
          if (!varElement) return;

          draggingVariable = varElement;
          isDragging = true;

          // Calculate offset
          const rect = varElement.getBoundingClientRect();
          offsetX = e.clientX - rect.left;
          offsetY = e.clientY - rect.top;

          // Show trash zone
          trashZone.classList.add("visible");

          // Add event listeners for drag
          document.addEventListener("mousemove", handleDrag);
          document.addEventListener("touchmove", handleTouchDrag, {
            passive: false,
          });
          document.addEventListener("mouseup", handleDragEnd);
          document.addEventListener("touchend", handleDragEnd);
        }

        // Handle drag
        function handleDrag(e) {
          if (!isDragging || !draggingVariable) return;

          const canvasRect = canvas.getBoundingClientRect();
          let x = (e.clientX - canvasRect.left - offsetX) / scale;
          let y = (e.clientY - canvasRect.top - offsetY) / scale;

          // Keep variable within canvas
          x = Math.max(
            0,
            Math.min(
              canvas.clientWidth / scale - draggingVariable.offsetWidth,
              x
            )
          );
          y = Math.max(
            0,
            Math.min(
              canvas.clientHeight / scale - draggingVariable.offsetHeight,
              y
            )
          );

          draggingVariable.style.left = x + "px";
          draggingVariable.style.top = y + "px";

          // Update connections
          updateConnections();

          // Check if over trash zone
          const trashRect = trashZone.getBoundingClientRect();
          if (e.clientY > trashRect.top) {
            trashZone.style.backgroundColor = "rgba(244, 67, 54, 0.2)";
          } else {
            trashZone.style.backgroundColor = "rgba(244, 67, 54, 0.1)";
          }
        }

        // Handle touch drag
        function handleTouchDrag(e) {
          e.preventDefault();
          const touch = e.touches[0];
          handleDrag({ clientX: touch.clientX, clientY: touch.clientY });
        }

        // Handle drag end
        function handleDragEnd(e) {
          if (isDragging && draggingVariable) {
            // Check if dropped on trash zone
            if (e.type !== "touchend") {
              const trashRect = trashZone.getBoundingClientRect();
              if (e.clientY > trashRect.top) {
                removeVariable(draggingVariable.id);
              }
            }
          }

          isDragging = false;
          draggingVariable = null;

          // Hide trash zone
          trashZone.classList.remove("visible");
          trashZone.style.backgroundColor = "rgba(244, 67, 54, 0.1)";

          // Remove event listeners
          document.removeEventListener("mousemove", handleDrag);
          document.removeEventListener("touchmove", handleTouchDrag);
          document.removeEventListener("mouseup", handleDragEnd);
          document.removeEventListener("touchend", handleDragEnd);
        }

        // Add click event to canvas for connection mode
        canvas.addEventListener("click", function (e) {
          if (!connectionMode) return;

          const varElement = e.target.closest(".variable");

          if (varElement) {
            if (!selectedVariable) {
              // First variable click
              selectedVariable = varElement;
              selectedVariable.classList.add("pulse");
              console.log("First variable selected:", selectedVariable.id);
            } else if (varElement !== selectedVariable) {
              // Second variable click - create connection
              console.log(
                "Creating connection:",
                selectedVariable.id,
                "to",
                varElement.id
              );
              createConnection(selectedVariable.id, varElement.id);

              // Reset selected variable
              selectedVariable.classList.remove("pulse");
              selectedVariable = null;
            }
          }
        });

        // Create connection between two variables
        function createConnection(sourceId, targetId) {
          // Check if connection already exists
          const exists = connections.some(
            (conn) =>
              (conn.source === sourceId && conn.target === targetId) ||
              (conn.source === targetId && conn.target === sourceId)
          );

          if (exists) {
            M.toast({ html: "Connection already exists" });
            return;
          }

          // Create the connection
          const connection = {
            id: "conn-" + Date.now(),
            source: sourceId,
            target: targetId,
            moderators: [], // Track moderators attached to this connection
          };

          connections.push(connection);
          drawConnection(connection);

          M.toast({ html: "Connection created" });
          return connection;
        }

        // Draw a connection line
        function drawConnection(connection) {
          const sourceEl = document.getElementById(connection.source);
          const targetEl = document.getElementById(connection.target);

          if (!sourceEl || !targetEl) {
            console.error(
              "Source or target element not found:",
              connection.source,
              connection.target
            );
            return;
          }

          // Check if connection element already exists
          let lineEl = document.getElementById("line-" + connection.id);
          let arrowEl = document.getElementById("arrow-" + connection.id);

          if (!lineEl) {
            lineEl = document.createElement("div");
            lineEl.className = "connector-line";
            lineEl.id = "line-" + connection.id;
            lineEl.dataset.connectionId = connection.id;
            lineEl.dataset.sourceId = connection.source;
            lineEl.dataset.targetId = connection.target;

            // Add click handler for moderator attachment mode
            lineEl.addEventListener("click", function (e) {
              if (moderatorAttachMode) {
                // Clear any previously selected connection
                document
                  .querySelectorAll(".connector-line.selected")
                  .forEach((el) => {
                    el.classList.remove("selected");
                  });

                // Select this connection
                lineEl.classList.add("selected");
                const connId = lineEl.dataset.connectionId;
                selectedConnection = connections.find(
                  (conn) => conn.id === connId
                );

                if (selectedConnection) {
                  M.toast({
                    html: "Connection selected. Now click on a moderator to attach it.",
                  });
                }
              }
            });

            // Add remove on double click
            lineEl.addEventListener("dblclick", function () {
              if (!moderatorAttachMode) {
                removeConnection(connection.id);
              }
            });

            canvas.appendChild(lineEl);

            // Store reference to the element
            connection.element = lineEl;
          }

          if (!arrowEl) {
            arrowEl = document.createElement("div");
            arrowEl.className = "arrow-head";
            arrowEl.id = "arrow-" + connection.id;
            canvas.appendChild(arrowEl);
          }

          // Calculate positions
          updateConnectionPosition(
            connection,
            sourceEl,
            targetEl,
            lineEl,
            arrowEl
          );

          // Update positions of any attached moderators
          connection.moderators.forEach((modId) => {
            const moderator = variables.find((v) => v.id === modId);
            if (moderator) {
              positionModeratorOnConnection(moderator);
            }
          });
        }

        // Update connection position
        function updateConnectionPosition(
          connection,
          sourceEl,
          targetEl,
          lineEl,
          arrowEl
        ) {
          const sourceRect = sourceEl.getBoundingClientRect();
          const targetRect = targetEl.getBoundingClientRect();
          const canvasRect = canvas.getBoundingClientRect();

          // Calculate center points
          const sourceX =
            sourceRect.left + sourceRect.width / 2 - canvasRect.left;
          const sourceY =
            sourceRect.top + sourceRect.height / 2 - canvasRect.top;
          const targetX =
            targetRect.left + targetRect.width / 2 - canvasRect.left;
          const targetY =
            targetRect.top + targetRect.height / 2 - canvasRect.top;

          // Calculate distance and angle
          const dx = targetX - sourceX;
          const dy = targetY - sourceY;
          const length = Math.sqrt(dx * dx + dy * dy);
          const angle = (Math.atan2(dy, dx) * 180) / Math.PI;

          // Position line
          lineEl.style.width = length + "px";
          lineEl.style.left = sourceX + "px";
          lineEl.style.top = sourceY + "px";
          lineEl.style.transform = `rotate(${angle}deg)`;

          // Position arrow head
          arrowEl.style.left = targetX - 7 + "px";
          arrowEl.style.top = targetY - 5 + "px";
          arrowEl.style.transform = `rotate(${angle}deg)`;
          arrowEl.style.borderWidth = "5px 0 5px 7px";
          arrowEl.style.borderColor =
            "transparent transparent transparent #333";
        }

        // Update all connections
        function updateConnections() {
          connections.forEach((conn) => {
            const sourceEl = document.getElementById(conn.source);
            const targetEl = document.getElementById(conn.target);
            const lineEl = document.getElementById("line-" + conn.id);
            const arrowEl = document.getElementById("arrow-" + conn.id);

            if (sourceEl && targetEl && lineEl && arrowEl) {
              updateConnectionPosition(
                conn,
                sourceEl,
                targetEl,
                lineEl,
                arrowEl
              );

              // Also update positions of any attached moderators
              if (conn.moderators && conn.moderators.length > 0) {
                conn.moderators.forEach((modId) => {
                  const moderator = variables.find((v) => v.id === modId);
                  if (moderator) {
                    positionModeratorOnConnection(moderator);
                  }
                });
              }
            }
          });
        }

        // Remove a connection
        function removeConnection(connectionId) {
          const connIndex = connections.findIndex(
            (conn) => conn.id === connectionId
          );
          if (connIndex !== -1) {
            const connection = connections[connIndex];

            // Detach any moderators from this connection
            if (connection.moderators && connection.moderators.length > 0) {
              connection.moderators.forEach((modId) => {
                const moderator = variables.find((v) => v.id === modId);
                if (moderator) {
                  moderator.modifies = null; // Detach from connection
                }
              });
            }

            connections.splice(connIndex, 1);

            // Remove DOM elements
            const lineEl = document.getElementById("line-" + connectionId);
            const arrowEl = document.getElementById("arrow-" + connectionId);
            if (lineEl) lineEl.remove();
            if (arrowEl) arrowEl.remove();

            M.toast({ html: "Connection removed" });
          }
        }

        // Attach a moderator to a connection
        function attachModeratorToConnection(moderator, connection) {
          // First, detach the moderator from any previous connection
          if (moderator.modifies) {
            const oldConnection = connections.find(
              (conn) => conn.id === moderator.modifies
            );
            if (oldConnection) {
              const modIndex = oldConnection.moderators.indexOf(moderator.id);
              if (modIndex !== -1) {
                oldConnection.moderators.splice(modIndex, 1);
              }
            }
          }

          // Attach to the new connection
          moderator.modifies = connection.id;

          // Add to the connection's moderators array if not already there
          if (!connection.moderators.includes(moderator.id)) {
            connection.moderators.push(moderator.id);
          }

          // Position the moderator visually on the connection
          positionModeratorOnConnection(moderator);
        }

        // Position a moderator on its connection
        function positionModeratorOnConnection(moderator) {
          if (!moderator.modifies) return;

          const connection = connections.find(
            (conn) => conn.id === moderator.modifies
          );
          if (!connection) return;

          const sourceEl = document.getElementById(connection.source);
          const targetEl = document.getElementById(connection.target);
          const lineEl = document.getElementById("line-" + connection.id);
          if (!sourceEl || !targetEl || !lineEl) return;

          const canvasRect = canvas.getBoundingClientRect();

          // Calculate center points of source and target
          const sourceRect = sourceEl.getBoundingClientRect();
          const targetRect = targetEl.getBoundingClientRect();
          const sourceX =
            sourceRect.left + sourceRect.width / 2 - canvasRect.left;
          const sourceY =
            sourceRect.top + sourceRect.height / 2 - canvasRect.top;
          const targetX =
            targetRect.left + targetRect.width / 2 - canvasRect.left;
          const targetY =
            targetRect.top + targetRect.height / 2 - canvasRect.top;

          // Position the moderator at the midpoint of the connection with a slight offset
          // based on the number of moderators on this connection
          const moderatorIndex = connection.moderators.indexOf(moderator.id);
          const totalModerators = connection.moderators.length;
          const offset = moderatorIndex - (totalModerators - 1) / 2;
          const midX = (sourceX + targetX) / 2;
          const midY = (sourceY + targetY) / 2;

          // Calculate normal vector to connection line
          const dx = targetX - sourceX;
          const dy = targetY - sourceY;
          const length = Math.sqrt(dx * dx + dy * dy);

          // Normalized normal vector (perpendicular to connection line)
          const nx = -dy / length;
          const ny = dx / length;

          // Offset distance based on moderator's strength
          const strength = moderator.strength || 5;
          const strengthFactor = strength === 0 ? 0.5 : 1; // Mediators have less offset

          // Calculate offset position
          const offsetDistance = 30 + offset * 40; // Base offset plus spacing between moderators
          const modX = midX + nx * offsetDistance * strengthFactor;
          const modY = midY + ny * offsetDistance * strengthFactor;

          // Position the moderator
          moderator.element.style.left =
            modX - moderator.element.offsetWidth / 2 + "px";
          moderator.element.style.top =
            modY - moderator.element.offsetHeight / 2 + "px";
        }

        // Remove a variable and its connections
        function removeVariable(variableId) {
          // Remove variable from array
          const varIndex = variables.findIndex((v) => v.id === variableId);
          if (varIndex !== -1) {
            const variable = variables[varIndex];

            // Check if it's the main dependent variable
            if (variable === mainDependentVar) {
              mainDependentVar = null;
            }

            // If it's a moderator attached to a connection, detach it
            if (variable.type === "moderator" && variable.modifies) {
              const connection = connections.find(
                (conn) => conn.id === variable.modifies
              );
              if (connection) {
                // Remove from the connection's moderators array
                const modIndex = connection.moderators.indexOf(variableId);
                if (modIndex !== -1) {
                  connection.moderators.splice(modIndex, 1);
                }
              }
            }

            variables.splice(varIndex, 1);

            // Remove DOM element
            const varEl = document.getElementById(variableId);
            if (varEl) varEl.remove();

            // Remove related connections
            const connToRemove = connections.filter(
              (conn) => conn.source === variableId || conn.target === variableId
            );

            connToRemove.forEach((conn) => {
              removeConnection(conn.id);
            });

            M.toast({ html: "Variable removed" });
          }
        }

        // Toggle connection mode
        toggleConnectModeBtn.addEventListener("click", function () {
          // First, exit moderator attachment mode if active
          if (moderatorAttachMode) {
            moderatorAttachMode = false;
            toggleModeratorModeBtn.classList.remove("red");
            toggleModeratorModeBtn.classList.add("purple", "lighten-2");

            // Reset any selected connection
            if (selectedConnection) {
              const lineEl = document.getElementById(
                "line-" + selectedConnection.id
              );
              if (lineEl) lineEl.classList.remove("selected");
              selectedConnection = null;
            }

            canvas.style.cursor = "default";
          }

          // Toggle connection mode
          connectionMode = !connectionMode;

          if (connectionMode) {
            canvas.classList.add("connection-mode");
            this.classList.add("red");
            this.classList.remove("blue");
            M.toast({
              html: "Connection mode: ON. Click on two variables to connect them.",
            });

            // Add cursor style to indicate connection mode
            canvas.style.cursor = "crosshair";
          } else {
            canvas.classList.remove("connection-mode");
            this.classList.add("blue");
            this.classList.remove("red");
            M.toast({ html: "Connection mode: OFF" });

            // Reset cursor style
            canvas.style.cursor = "default";

            // Reset selected variable if any
            if (selectedVariable) {
              selectedVariable.classList.remove("pulse");
              selectedVariable = null;
            }
          }
        });

        // Toggle moderator attachment mode
        toggleModeratorModeBtn.addEventListener("click", function () {
          // First, exit connection mode if active
          if (connectionMode) {
            connectionMode = false;
            toggleConnectModeBtn.classList.remove("red");
            toggleConnectModeBtn.classList.add("blue");

            // Reset selected variable if any
            if (selectedVariable) {
              selectedVariable.classList.remove("pulse");
              selectedVariable = null;
            }

            canvas.classList.remove("connection-mode");
          }

          // Toggle moderator attachment mode
          moderatorAttachMode = !moderatorAttachMode;

          if (moderatorAttachMode) {
            this.classList.add("red");
            this.classList.remove("purple", "lighten-2");
            M.toast({
              html: "Moderator attachment mode: ON. First click on a connection, then on a moderator to attach it.",
            });

            // Reset any previously selected connection
            document
              .querySelectorAll(".connector-line.selected")
              .forEach((el) => {
                el.classList.remove("selected");
              });
            selectedConnection = null;

            // Add cursor style to indicate moderator attachment mode
            canvas.style.cursor = "cell";
          } else {
            this.classList.remove("red");
            this.classList.add("purple", "lighten-2");
            M.toast({ html: "Moderator attachment mode: OFF" });

            // Reset any selected connection
            if (selectedConnection) {
              const lineEl = document.getElementById(
                "line-" + selectedConnection.id
              );
              if (lineEl) lineEl.classList.remove("selected");
              selectedConnection = null;
            }

            // Reset cursor style
            canvas.style.cursor = "default";
          }
        });

        // Set a variable as the main dependent variable with a double-click
        function setAsMainDependent(varId) {
          const variable = variables.find((v) => v.id === varId);

          if (variable && variable.type === "dependent") {
            if (mainDependentVar === variable) {
              // Already set as main
              M.toast({
                html: "This is already set as the main dependent variable",
              });
              return;
            }

            mainDependentVar = variable;
            M.toast({ html: "Set as main dependent variable (outcome)" });

            // Highlight the main dependent variable
            variables.forEach((v) => {
              if (v.type === "dependent") {
                if (v === mainDependentVar) {
                  v.element.style.boxShadow = "0 0 10px rgba(239, 83, 80, 0.8)";
                } else {
                  v.element.style.boxShadow = "0 2px 5px rgba(0, 0, 0, 0.2)";
                }
              }
            });
          } else if (variable && variable.type !== "dependent") {
            M.toast({
              html: "Only dependent variables can be set as the main outcome",
            });
          }
        }

        // Clear canvas
        clearCanvasBtn.addEventListener("click", function () {
          if (confirm("Are you sure you want to clear the canvas?")) {
            variables.forEach((variable) => {
              const varEl = document.getElementById(variable.id);
              if (varEl) varEl.remove();
            });

            connections.forEach((conn) => {
              const lineEl = document.getElementById("line-" + conn.id);
              const arrowEl = document.getElementById("arrow-" + conn.id);
              if (lineEl) lineEl.remove();
              if (arrowEl) arrowEl.remove();
            });

            variables = [];
            connections = [];
            mainDependentVar = null;

            M.toast({ html: "Canvas cleared" });
          }
        });

        // Save model
        saveBtn.addEventListener("click", function () {
          const modelData = {
            variables: variables.map((v) => ({
              id: v.id,
              name: v.element.querySelector("h6").textContent,
              type: v.type,
              color: v.color,
              strength: v.strength || (v.type === "moderator" ? 5 : null),
              modifies: v.modifies, // Store which connection the moderator modifies
              left: parseFloat(v.element.style.left),
              top: parseFloat(v.element.style.top),
              minimized: v.element.classList.contains("minimized"),
              isMainDependent: v === mainDependentVar,
            })),
            connections: connections.map((c) => ({
              id: c.id,
              source: c.source,
              target: c.target,
              moderators: c.moderators || [],
            })),
          };

          const dataStr = JSON.stringify(modelData, null, 2);
          const dataUri =
            "data:application/json;charset=utf-8," +
            encodeURIComponent(dataStr);

          const exportName =
            "ishikawa-model-" + new Date().toISOString().slice(0, 10) + ".json";

          const linkElement = document.createElement("a");
          linkElement.setAttribute("href", dataUri);
          linkElement.setAttribute("download", exportName);
          linkElement.click();

          M.toast({ html: "Model saved" });
        });

        // Load model
        loadBtn.addEventListener("click", function () {
          loadInput.click();
        });

        loadInput.addEventListener("change", function (e) {
          const file = e.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = function (e) {
            try {
              // Clear current canvas
              clearCanvas();

              const modelData = JSON.parse(e.target.result);

              // First pass: Add all variables
              modelData.variables.forEach((v) => {
                const strength =
                  v.type === "moderator"
                    ? v.strength !== undefined
                      ? v.strength
                      : 5
                    : null;
                const varEl = addVariable(
                  v.name,
                  v.type,
                  v.color,
                  {
                    left: v.left,
                    top: v.top,
                  },
                  strength
                );

                if (v.minimized) {
                  varEl.classList.add("minimized");
                }

                // Set as main dependent variable if applicable
                if (v.isMainDependent && v.type === "dependent") {
                  const newVar = variables.find(
                    (variable) => variable.id === varEl.id
                  );
                  if (newVar) {
                    mainDependentVar = newVar;
                    newVar.element.style.boxShadow =
                      "0 0 10px rgba(239, 83, 80, 0.8)";
                  }
                }
              });

              // Second pass: Add connections
              modelData.connections.forEach((c) => {
                createConnection(c.source, c.target);
              });

              // Third pass: Setup moderator attachments
              modelData.variables.forEach((v) => {
                if (v.type === "moderator" && v.modifies) {
                  const moderator = variables.find((m) => m.id === v.id);
                  const connection = connections.find(
                    (c) => c.id === v.modifies
                  );

                  if (moderator && connection) {
                    attachModeratorToConnection(moderator, connection);

                    // Update strength
                    if (v.strength !== undefined) {
                      const strengthSlider =
                        moderator.element.querySelector(".strength-slider");
                      const strengthValue =
                        moderator.element.querySelector(".strength-value");

                      if (strengthSlider && strengthValue) {
                        strengthSlider.value = v.strength;
                        strengthValue.textContent = v.strength;
                        moderator.strength = v.strength;
                        updateModeratorAppearance(moderator);
                      }
                    }
                  }
                }
              });

              M.toast({ html: "Model loaded" });
            } catch (error) {
              console.error(error);
              M.toast({ html: "Error loading model file" });
            }
          };

          reader.readAsText(file);
          this.value = null; // Reset input
        });

        // Export as PNG
        exportBtn.addEventListener("click", function () {
          // Use html2canvas library to export
          if (typeof html2canvas === "undefined") {
            // Load html2canvas dynamically if not available
            const script = document.createElement("script");
            script.src =
              "https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js";
            script.onload = captureCanvas;
            document.head.appendChild(script);
          } else {
            captureCanvas();
          }

          function captureCanvas() {
            M.toast({ html: "Generating image..." });

            // Temporarily remove zoom scale for clean capture
            const originalTransform = canvas.style.transform;
            canvas.style.transform = "none";

            html2canvas(canvas, {
              backgroundColor: "#ffffff",
              scale: 2,
              logging: false,
            })
              .then(function (canvas) {
                const dataUrl = canvas.toDataURL("image/png");
                const exportName =
                  "ishikawa-model-" +
                  new Date().toISOString().slice(0, 10) +
                  ".png";

                const linkElement = document.createElement("a");
                linkElement.setAttribute("href", dataUrl);
                linkElement.setAttribute("download", exportName);
                linkElement.click();

                // Restore zoom
                canvas.style.transform = originalTransform;

                M.toast({ html: "PNG exported" });
              })
              .catch(function (error) {
                console.error(error);
                M.toast({ html: "Error exporting image" });
                canvas.style.transform = originalTransform;
              });
          }
        });

        // Clear canvas helper function
        function clearCanvas() {
          document
            .querySelectorAll(
              ".variable, .connector-line, .arrow-head, .ishikawa-main-bone, .ishikawa-branch"
            )
            .forEach((el) => {
              el.remove();
            });

          variables = [];
          connections = [];
          mainDependentVar = null;
        }

        // Zoom controls
        zoomInBtn.addEventListener("click", function () {
          scale = Math.min(scale + 0.1, 2);
          applyZoom();
        });

        zoomOutBtn.addEventListener("click", function () {
          scale = Math.max(scale - 0.1, 0.5);
          applyZoom();
        });

        zoomResetBtn.addEventListener("click", function () {
          scale = 1;
          applyZoom();
        });

        function applyZoom() {
          canvas.style.transform = `scale(${scale})`;
          canvas.style.transformOrigin = "top left";
        }

        // Create tooltip
        function createTooltip() {
          if (!tooltip) {
            tooltip = document.createElement("div");
            tooltip.className = "tooltip";
            document.body.appendChild(tooltip);
          }
          return tooltip;
        }

        // Handle mouse over connections to show info
        canvas.addEventListener("mouseover", function (e) {
          const lineEl = e.target.closest(".connector-line");
          if (lineEl) {
            const sourceId = lineEl.dataset.sourceId;
            const targetId = lineEl.dataset.targetId;

            const sourceVar = variables.find((v) => v.id === sourceId);
            const targetVar = variables.find((v) => v.id === targetId);

            if (sourceVar && targetVar) {
              const tooltip = createTooltip();
              const sourceName =
                sourceVar.element.querySelector("h6").textContent;
              const targetName =
                targetVar.element.querySelector("h6").textContent;

              tooltip.textContent = `${sourceName} â†’ ${targetName}`;
              tooltip.style.display = "block";
              tooltip.style.left = e.clientX + 10 + "px";
              tooltip.style.top = e.clientY + 10 + "px";
            }
          }
        });

        canvas.addEventListener("mouseout", function (e) {
          if (e.target.closest(".connector-line") && tooltip) {
            tooltip.style.display = "none";
          }
        });

        canvas.addEventListener("mousemove", function (e) {
          if (
            e.target.closest(".connector-line") &&
            tooltip &&
            tooltip.style.display === "block"
          ) {
            tooltip.style.left = e.clientX + 10 + "px";
            tooltip.style.top = e.clientY + 10 + "px";
          }
        });

        // Helper function to get contrast color (black or white) based on background
        function getContrastColor(hexColor) {
          // Convert hex to RGB
          const r = parseInt(hexColor.substr(1, 2), 16);
          const g = parseInt(hexColor.substr(3, 2), 16);
          const b = parseInt(hexColor.substr(5, 2), 16);

          // Calculate luminance
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;

          return luminance > 0.5 ? "#000000" : "#ffffff";
        }

        // Helper function to adjust color lightness/darkness
        function adjustColor(hexColor, amount) {
          // Convert hex to RGB
          let r = parseInt(hexColor.substr(1, 2), 16);
          let g = parseInt(hexColor.substr(3, 2), 16);
          let b = parseInt(hexColor.substr(5, 2), 16);

          // Adjust values
          r = Math.max(0, Math.min(255, r + amount));
          g = Math.max(0, Math.min(255, g + amount));
          b = Math.max(0, Math.min(255, b + amount));

          // Convert back to hex
          return `#${((1 << 24) + (r << 16) + (g << 8) + b)
            .toString(16)
            .slice(1)}`;
        }

        // Auto-layout button click handler
        autoLayoutBtn.addEventListener("click", function () {
          applyIshikawaLayout();
        });

        // Handle window resize
        window.addEventListener("resize", function () {
          updateConnections();
        });

        // Initial toast message
        setTimeout(function () {
          M.toast({ html: "Welcome to Ishikawa Research Model Builder!" });
          setTimeout(function () {
            M.toast({
              html: "Add variables, create connections, and apply the fishbone layout",
            });
          }, 2000);
          setTimeout(function () {
            M.toast({
              html: "Moderators can be attached to connections using the purple button",
            });
          }, 4000);
          setTimeout(function () {
            M.toast({
              html: "Adjust moderator strength to 0 to turn it into a mediator",
            });
          }, 6000);
        }, 1000);
      });
    </script>
  </body>
</html>
